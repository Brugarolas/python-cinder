<!DOCTYPE html>
<!--
Copyright 2009 The Go Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be found in
the LICENSE.go file.
Copyright (c) Meta Platforms, Inc. and affiliates.
-->
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>
        body {
            font-size: 14px;
            font-family: Arial, sans-serif;
        }

        h1 {
            font-size: 18px;
            display: inline-block;
            margin: 0 1em .5em 0;
        }

        #helplink {
            display: inline-block;
        }

        #help {
            display: none;
        }

        .stats {
            font-size: 60%;
        }

        table {
            border: 1px solid black;
            table-layout: fixed;
        }

        th,
        td {
            border: 1px solid black;
            white-space: nowrap;
            vertical-align: top;
            padding: 5px;
        }

        td>h2 {
            cursor: pointer;
            font-size: 120%;
            margin: 5px 0px 5px 0px;
        }

        td.collapsed {
            font-size: 12px;
            width: 12px;
            border: 1px solid white;
            padding: 2px;
            cursor: pointer;
            background: #fafafa;
        }

        td.collapsed div {
            text-align: right;
            transform: rotate(180deg);
            writing-mode: vertical-lr;
            white-space: pre;
        }

        code,
        pre,
        .lines,
        .ast {
            font-family: Menlo, monospace;
            font-size: 12px;
        }

        pre {
            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;
        }

        .allow-x-scroll {
            overflow-x: scroll;
        }

        .lines {
            float: left;
            overflow: hidden;
            text-align: right;
            margin-top: 7px;
        }

        .lines div {
            padding-right: 10px;
            color: gray;
        }

        div.line-number {
            font-size: 12px;
        }

        .ast {
            white-space: nowrap;
        }

        td.ssa-prog {
            width: 600px;
            word-wrap: break-word;
        }

        li {
            list-style-type: none;
        }

        li.ssa-value-list {
            display: inline;
        }

        li.ssa-start-block {
            padding: 0;
            margin: 0;
        }

        li.ssa-end-block {
            padding: 0;
            margin: 0;
        }

        ul.ssa-print-func {
            padding-left: 0;
        }

        li.ssa-start-block button {
            padding: 0 1em;
            margin: 0;
            border: none;
            display: inline;
            font-size: 14px;
            float: right;
        }

        button:hover {
            background-color: #eee;
            cursor: pointer;
        }

        dl.ssa-gen {
            padding-left: 0;
        }

        dt.ssa-prog-src {
            padding: 0;
            margin: 0;
            float: left;
            width: 4em;
        }

        dd.ssa-prog {
            padding: 0;
            margin-right: 0;
            margin-left: 4em;
        }

        .generic-instruction {
          background-color: #F08080;
        }

        .dead-value {
            color: gray;
        }

        .dead-block {
            opacity: 0.5;
        }

        .depcycle {
            font-style: italic;
        }

        .line-number {
            font-size: 11px;
        }

        .no-line-number {
            font-size: 11px;
            color: gray;
        }

        .zoom {
            position: absolute;
            float: left;
            white-space: nowrap;
            background-color: #eee;
        }

        .zoom a:link,
        .zoom a:visited {
            text-decoration: none;
            color: blue;
            font-size: 16px;
            padding: 4px 2px;
        }

        svg {
            cursor: default;
            outline: 1px solid #eee;
            width: 100%;
        }

        body.darkmode {
            background-color: rgb(21, 21, 21);
            color: rgb(230, 255, 255);
            opacity: 100%;
        }

        td.darkmode {
            background-color: rgb(21, 21, 21);
            border: 1px solid gray;
        }

        body.darkmode table,
        th {
            border: 1px solid gray;
        }

        body.darkmode text {
            fill: white;
        }

        body.darkmode svg polygon:first-child {
            fill: rgb(21, 21, 21);
        }

        .highlight-aquamarine {
            background-color: aquamarine;
            color: black;
        }

        .highlight-coral {
            background-color: coral;
            color: black;
        }

        .highlight-lightpink {
            background-color: lightpink;
            color: black;
        }

        .highlight-lightsteelblue {
            background-color: lightsteelblue;
            color: black;
        }

        .highlight-palegreen {
            background-color: palegreen;
            color: black;
        }

        .highlight-skyblue {
            background-color: skyblue;
            color: black;
        }

        .highlight-lightgray {
            background-color: lightgray;
            color: black;
        }

        .highlight-yellow {
            background-color: yellow;
            color: black;
        }

        .highlight-lime {
            background-color: lime;
            color: black;
        }

        .highlight-khaki {
            background-color: khaki;
            color: black;
        }

        .highlight-aqua {
            background-color: aqua;
            color: black;
        }

        .highlight-salmon {
            background-color: salmon;
            color: black;
        }

        /* Ensure all dead values/blocks continue to have gray font color in dark mode with highlights */
        .dead-value span.highlight-aquamarine,
        .dead-block.highlight-aquamarine,
        .dead-value span.highlight-coral,
        .dead-block.highlight-coral,
        .dead-value span.highlight-lightpink,
        .dead-block.highlight-lightpink,
        .dead-value span.highlight-lightsteelblue,
        .dead-block.highlight-lightsteelblue,
        .dead-value span.highlight-palegreen,
        .dead-block.highlight-palegreen,
        .dead-value span.highlight-skyblue,
        .dead-block.highlight-skyblue,
        .dead-value span.highlight-lightgray,
        .dead-block.highlight-lightgray,
        .dead-value span.highlight-yellow,
        .dead-block.highlight-yellow,
        .dead-value span.highlight-lime,
        .dead-block.highlight-lime,
        .dead-value span.highlight-khaki,
        .dead-block.highlight-khaki,
        .dead-value span.highlight-aqua,
        .dead-block.highlight-aqua,
        .dead-value span.highlight-salmon,
        .dead-block.highlight-salmon {
            color: gray;
        }

        .outline-blue {
            outline: #2893ff solid 2px;
        }

        .outline-red {
            outline: red solid 2px;
        }

        .outline-blueviolet {
            outline: blueviolet solid 2px;
        }

        .outline-darkolivegreen {
            outline: darkolivegreen solid 2px;
        }

        .outline-fuchsia {
            outline: fuchsia solid 2px;
        }

        .outline-sienna {
            outline: sienna solid 2px;
        }

        .outline-gold {
            outline: gold solid 2px;
        }

        .outline-orangered {
            outline: orangered solid 2px;
        }

        .outline-teal {
            outline: teal solid 2px;
        }

        .outline-maroon {
            outline: maroon solid 2px;
        }

        .outline-black {
            outline: black solid 2px;
        }

        ellipse.outline-blue {
            stroke-width: 2px;
            stroke: #2893ff;
        }

        ellipse.outline-red {
            stroke-width: 2px;
            stroke: red;
        }

        ellipse.outline-blueviolet {
            stroke-width: 2px;
            stroke: blueviolet;
        }

        ellipse.outline-darkolivegreen {
            stroke-width: 2px;
            stroke: darkolivegreen;
        }

        ellipse.outline-fuchsia {
            stroke-width: 2px;
            stroke: fuchsia;
        }

        ellipse.outline-sienna {
            stroke-width: 2px;
            stroke: sienna;
        }

        ellipse.outline-gold {
            stroke-width: 2px;
            stroke: gold;
        }

        ellipse.outline-orangered {
            stroke-width: 2px;
            stroke: orangered;
        }

        ellipse.outline-teal {
            stroke-width: 2px;
            stroke: teal;
        }

        ellipse.outline-maroon {
            stroke-width: 2px;
            stroke: maroon;
        }

        ellipse.outline-black {
            stroke-width: 2px;
            stroke: black;
        }

        /* Capture alternative for outline-black and ellipse.outline-black when in dark mode */
        body.darkmode .outline-black {
            outline: gray solid 2px;
        }

        body.darkmode ellipse.outline-black {
            outline: gray solid 2px;
        }
    </style>

    <script type="text/javascript">
        // Contains phase names which are expanded by default. Other columns are collapsed.
        let expandedDefault = @EXPANDED@;
        if (history.state === null) {
            history.pushState({
                expandedDefault
            }, "", location.href);
        }

        // ordered list of all available highlight colors
        var highlights = [
            "highlight-aquamarine",
            "highlight-coral",
            "highlight-lightpink",
            "highlight-lightsteelblue",
            "highlight-palegreen",
            "highlight-skyblue",
            "highlight-lightgray",
            "highlight-yellow",
            "highlight-lime",
            "highlight-khaki",
            "highlight-aqua",
            "highlight-salmon"
        ];

        // state: which value is highlighted this color?
        var highlighted = {};
        for (var i = 0; i < highlights.length; i++) {
            highlighted[highlights[i]] = "";
        }

        // ordered list of all available outline colors
        var outlines = [
            "outline-blue",
            "outline-red",
            "outline-blueviolet",
            "outline-darkolivegreen",
            "outline-fuchsia",
            "outline-sienna",
            "outline-gold",
            "outline-orangered",
            "outline-teal",
            "outline-maroon",
            "outline-black"
        ];

        // state: which value is outlined this color?
        var outlined = {};
        for (var i = 0; i < outlines.length; i++) {
            outlined[outlines[i]] = "";
        }

        function toggle_cell(id) {
            var e = document.getElementById(id);
            if (e.style.display == 'table-cell') {
                e.style.display = 'none';
            } else {
                e.style.display = 'table-cell';
            }
        }

        function toggler(phase) {
            return function() {
                toggle_cell(phase + '-col');
                toggle_cell(phase + '-exp');
                const i = expandedDefault.indexOf(phase);
                if (i !== -1) {
                    expandedDefault.splice(i, 1);
                } else {
                    expandedDefault.push(phase);
                }
                history.pushState({
                    expandedDefault
                }, "", location.href);
            };
        }

        function setupTds() {
          // Go through all columns and collapse needed phases.
          const td = document.getElementsByTagName("td");
          for (let i = 0; i < td.length; i++) {
              const id = td[i].id;
              const phase = id.substr(0, id.length - 4);
              let show = expandedDefault.indexOf(phase) !== -1

              // If show == false, check to see if this is a combined column (multiple phases).
              // If combined, check each of the phases to see if they are in our expandedDefaults.
              // If any are found, that entire combined column gets shown.
              if (!show) {
                  const combined = phase.split('--+--');
                  const len = combined.length;
                  if (len > 1) {
                      for (let i = 0; i < len; i++) {
                          const num = expandedDefault.indexOf(combined[i]);
                          if (num !== -1) {
                              expandedDefault.splice(num, 1);
                              if (expandedDefault.indexOf(phase) === -1) {
                                  expandedDefault.push(phase);
                                  show = true;
                              }
                          }
                      }
                  }
              }
              if (id.endsWith("-exp")) {
                  const h2Els = td[i].getElementsByTagName("h2");
                  const len = h2Els.length;
                  if (len > 0) {
                      for (let i = 0; i < len; i++) {
                          h2Els[i].addEventListener('click', toggler(phase));
                      }
                  }
              } else {
                  td[i].addEventListener('click', toggler(phase));
              }
              if (id.endsWith("-col") && show || id.endsWith("-exp") && !show) {
                  td[i].style.display = 'none';
                  continue;
              }
              td[i].style.display = 'table-cell';
          }

          // find all svg block nodes, add their block classes
          var nodes = document.querySelectorAll('*[id^="graph_node_"]');
          for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var name = node.id.toString();
              var block = name.substring(name.lastIndexOf("_") + 1);
              node.classList.remove("node");
              node.classList.add(block);
              node.addEventListener('click', ssaBlockClicked);
              var ellipse = node.getElementsByTagName('ellipse')[0];
              ellipse.classList.add(block);
              ellipse.addEventListener('click', ssaBlockClicked);
          }

          // make big graphs smaller
          var targetScale = 0.5;
          var nodes = document.querySelectorAll('*[id^="svg_graph_"]');
          // TODO: Implement smarter auto-zoom using the viewBox attribute
          // and in case of big graphs set the width and height of the svg graph to
          // maximum allowed.
          for (var i = 0; i < nodes.length; i++) {
              var node = nodes[i];
              var name = node.id.toString();
              var phase = name.substring(name.lastIndexOf("_") + 1);
              var gNode = document.getElementById("g_graph_" + phase);
              var scale = gNode.transform.baseVal.getItem(0).matrix.a;
              if (scale > targetScale) {
                  node.width.baseVal.value *= targetScale / scale;
                  node.height.baseVal.value *= targetScale / scale;
              }
          }
        }

        function setupSSA() {
            var ssaElemClicked = function(elem, event, selections, selected) {
                event.stopPropagation();

                // find all values with the same name
                var c = elem.classList.item(0);
                var x = document.getElementsByClassName(c);

                // if selected, remove selections from all of them
                // otherwise, attempt to add

                var remove = "";
                for (var i = 0; i < selections.length; i++) {
                    var color = selections[i];
                    if (selected[color] == c) {
                        remove = color;
                        break;
                    }
                }

                if (remove != "") {
                    for (var i = 0; i < x.length; i++) {
                        x[i].classList.remove(remove);
                    }
                    selected[remove] = "";
                    return;
                }

                // we're adding a selection
                // find first available color
                var avail = "";
                for (var i = 0; i < selections.length; i++) {
                    var color = selections[i];
                    if (selected[color] == "") {
                        avail = color;
                        break;
                    }
                }
                if (avail == "") {
                    alert("out of selection colors; go add more");
                    return;
                }

                // set that as the selection
                for (var i = 0; i < x.length; i++) {
                    x[i].classList.add(avail);
                }
                selected[avail] = c;
            };

            var ssaValueClicked = function(event) {
                ssaElemClicked(this, event, highlights, highlighted);
            };

            var ssaBlockClicked = function(event) {
                ssaElemClicked(this, event, outlines, outlined);
            };

            var ssaBytecodeClicked = function(event) {
                ssaElemClicked(this, event, highlights, highlighted);
            }

            var ssavalues = document.getElementsByClassName("ssa-value");
            for (var i = 0; i < ssavalues.length; i++) {
                ssavalues[i].addEventListener('click', ssaValueClicked);
            }

            var ssalongvalues = document.getElementsByClassName("ssa-long-value");
            for (var i = 0; i < ssalongvalues.length; i++) {
                // don't attach listeners to li nodes, just the spans they contain
                if (ssalongvalues[i].nodeName == "SPAN") {
                    ssalongvalues[i].addEventListener('click', ssaValueClicked);
                }
            }

            var ssablocks = document.getElementsByClassName("ssa-block");
            for (var i = 0; i < ssablocks.length; i++) {
                ssablocks[i].addEventListener('click', ssaBlockClicked);
            }

            var lines = document.getElementsByClassName("line-number");
            for (var i = 0; i < lines.length; i++) {
                lines[i].addEventListener('click', ssaValueClicked);
            }

            var lines = document.getElementsByClassName("bytecode-offset");
            for (var i = 0; i < lines.length; i++) {
                if (!lines[i].classList.contains("bytecode-instruction")) {
                    // Only make bytecode highlight HIR and LIR, not the other
                    // way around.
                    continue;
                }
                lines[i].addEventListener('click', ssaBytecodeClicked);
            }
        }

        window.onload = function() {
            if (history.state !== null) {
                expandedDefault = history.state.expandedDefault;
            }
            updateHTML();
            if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
                toggleDarkMode();
                document.getElementById("dark-mode-button").checked = true;
            }
        }

        function toggle_visibility(id) {
            var e = document.getElementById(id);
            if (e.style.display == 'block') {
                e.style.display = 'none';
            } else {
                e.style.display = 'block';
            }
        }

        function hideBlock(el) {
            var es = el.parentNode.parentNode.getElementsByClassName("ssa-value-list");
            if (es.length === 0)
                return;
            var e = es[0];
            if (e.style.display === 'block' || e.style.display === '') {
                e.style.display = 'none';
                el.innerHTML = '+';
            } else {
                e.style.display = 'block';
                el.innerHTML = '-';
            }
        }

        // TODO: scale the graph with the viewBox attribute.
        function graphReduce(id) {
            var node = document.getElementById(id);
            if (node) {
                node.width.baseVal.value *= 0.9;
                node.height.baseVal.value *= 0.9;
            }
            return false;
        }

        function graphEnlarge(id) {
            var node = document.getElementById(id);
            if (node) {
                node.width.baseVal.value *= 1.1;
                node.height.baseVal.value *= 1.1;
            }
            return false;
        }

        function makeDraggable(event) {
            var svg = event.target;
            if (window.PointerEvent) {
                svg.addEventListener('pointerdown', startDrag);
                svg.addEventListener('pointermove', drag);
                svg.addEventListener('pointerup', endDrag);
                svg.addEventListener('pointerleave', endDrag);
            } else {
                svg.addEventListener('mousedown', startDrag);
                svg.addEventListener('mousemove', drag);
                svg.addEventListener('mouseup', endDrag);
                svg.addEventListener('mouseleave', endDrag);
            }

            var point = svg.createSVGPoint();
            var isPointerDown = false;
            var pointerOrigin;
            var viewBox = svg.viewBox.baseVal;

            function getPointFromEvent(event) {
                point.x = event.clientX;
                point.y = event.clientY;

                // We get the current transformation matrix of the SVG and we inverse it
                var invertedSVGMatrix = svg.getScreenCTM().inverse();
                return point.matrixTransform(invertedSVGMatrix);
            }

            function startDrag(event) {
                isPointerDown = true;
                pointerOrigin = getPointFromEvent(event);
            }

            function drag(event) {
                if (!isPointerDown) {
                    return;
                }
                event.preventDefault();

                var pointerPosition = getPointFromEvent(event);
                viewBox.x -= (pointerPosition.x - pointerOrigin.x);
                viewBox.y -= (pointerPosition.y - pointerOrigin.y);
            }

            function endDrag(event) {
                isPointerDown = false;
            }
        }

        function togglePerfAnnotations() {
          const elts = [...document.querySelectorAll('.perf-annotation')];
          elts.forEach(elt => {
            elt.style.display = elt.style.display == 'none' ? 'block' : 'none';
          });
        }

        function toggleDarkMode() {
            document.body.classList.toggle('darkmode');

            // Collect all of the "collapsed" elements and apply dark mode on each collapsed column
            const collapsedEls = document.getElementsByClassName('collapsed');
            const len = collapsedEls.length;

            for (let i = 0; i < len; i++) {
                collapsedEls[i].classList.toggle('darkmode');
            }

            // Collect and spread the appropriate elements from all of the svgs on the page into one array
            const svgParts = [
                ...document.querySelectorAll('path'),
                ...document.querySelectorAll('ellipse'),
                ...document.querySelectorAll('polygon'),
            ];

            // Iterate over the svgParts specifically looking for white and black fill/stroke to be toggled.
            // The verbose conditional is intentional here so that we do not mutate any svg path, ellipse, or polygon that is of any color other than white or black.
            svgParts.forEach(el => {
                if (el.attributes.stroke.value === 'white') {
                    el.attributes.stroke.value = 'black';
                } else if (el.attributes.stroke.value === 'black') {
                    el.attributes.stroke.value = 'white';
                }
                if (el.attributes.fill.value === 'white') {
                    el.attributes.fill.value = 'black';
                } else if (el.attributes.fill.value === 'black') {
                    el.attributes.fill.value = 'white';
                }
            });
        }

        // Parse JSON from the string. Return object if valid JSON, otherwise
        // return undefined.
        function parseJSON(str) {
          try {
            return JSON.parse(str);
          } catch (e) {
            return undefined;
          }
        }

        function ssaError(str) {
          document.getElementById("ssa-error").innerHTML = str;
        }

        function ssaSuccess() {
          document.getElementById("ssa-error").innerHTML = "";
        }

        function formatLine(lineno) {
          const span = document.createElement("span");
          if (lineno === undefined || lineno == -1) {
            span.setAttribute("class", "no-line-number");
            span.appendChild(document.createTextNode("(?)"));
          } else {
            span.setAttribute("class", `l${lineno} line-number`);
            span.appendChild(document.createTextNode(`(${lineno})`));
          }
          return span;
        }

        function collapseButton() {
          const result = document.createElement("button");
          result.setAttribute("onclick", "hideBlock(this)");
          result.innerText = "-";
          return result;
        }

        function formatBlock(block_name) {
          const result = document.createElement("span");
          result.setAttribute("class", `${block_name} ssa-block`);
          result.innerText = block_name;
          return result;
        }

        const GENERIC_OPCODES = [
          "BinaryOp",
          "Compare",
          "CompareBool",
          "DeleteAttr",
          "DeleteSubscr",
          "GetIter",
          "InPlaceOp",
          "InvokeIterNext",
          "IsInstance",
          "IsTruthy",
          "LoadAttr",
          "LoadAttrSpecial",
          "LoadGlobal",
          "LoadMethod",
          "StoreAttr",
          "StoreSubscr",
          "UnaryOp",
          "UnpackExToTuple",
        ];

        function isGeneric(instr) {
          const first_bracket = instr.indexOf("<");
          if (first_bracket != -1) {
            instr = instr.substr(0, first_bracket);
          }
          for (const generic of GENERIC_OPCODES) {
            if (instr == generic) {
              return true;
            }
          }
          return false;
        }

        function formatInstr(instr) {
          const result = document.createElement("li");
          if (instr.hasOwnProperty("bytecode_offset")) {
            result.setAttribute("class", `bc${instr.bytecode_offset} bytecode-offset ssa-long-value`);
          } else {
            result.setAttribute("class", "ssa-long-value");
          }
          result.appendChild(formatLine(instr.line));
          result.appendChild(document.createTextNode(" "));
          if (instr.output !== undefined) {
            const output = instr.output === undefined ? "_" : instr.output;
            const long_value = document.createElement("span");
            long_value.setAttribute("class", `${output} ssa-long-value`);
            const value = document.createElement("span");
            value.setAttribute("class", `${output} ssa-value`);
            if (instr.type === undefined) {
              value.appendChild(document.createTextNode(`${output}`));
            } else {
              value.appendChild(document.createTextNode(`${output}:${instr.type}`));
            }
            long_value.appendChild(value);
            result.appendChild(long_value);
            result.appendChild(document.createTextNode(" = "));
          }
          if (isGeneric(instr.opcode)) {
            const generic = document.createElement("span");
            generic.setAttribute("class", "generic-instruction");
            generic.appendChild(document.createTextNode(instr.opcode));
            result.appendChild(generic);
          } else {
            result.appendChild(document.createTextNode(instr.opcode));
          }
          if (instr.operands !== undefined) {
            for (const op of instr.operands) {
              const op_node = document.createElement("span");
              op_node.setAttribute("class", `${op} ssa-value`);
              op_node.appendChild(document.createTextNode(op));
              result.appendChild(document.createTextNode(" "));
              result.appendChild(op_node);
            }
          }
          return result;
        }

        // https://stackoverflow.com/a/1144249/569183
        function deepCompare () {
          var i, l, leftChain, rightChain;

          function compare2Objects (x, y) {
            var p;

            // remember that NaN === NaN returns false
            // and isNaN(undefined) returns true
            if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
                 return true;
            }

            // Compare primitives and functions.
            // Check if both arguments link to the same object.
            // Especially useful on the step where we compare prototypes
            if (x === y) {
                return true;
            }

            // Works in case when functions are created in constructor.
            // Comparing dates is a common scenario. Another built-ins?
            // We can even handle functions passed across iframes
            if ((typeof x === 'function' && typeof y === 'function') ||
               (x instanceof Date && y instanceof Date) ||
               (x instanceof RegExp && y instanceof RegExp) ||
               (x instanceof String && y instanceof String) ||
               (x instanceof Number && y instanceof Number)) {
                return x.toString() === y.toString();
            }

            // At last checking prototypes as good as we can
            if (!(x instanceof Object && y instanceof Object)) {
                return false;
            }

            if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
                return false;
            }

            if (x.constructor !== y.constructor) {
                return false;
            }

            if (x.prototype !== y.prototype) {
                return false;
            }

            // Check for infinitive linking loops
            if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
                 return false;
            }

            // Quick checking of one object being a subset of another.
            // todo: cache the structure of arguments[0] for performance
            for (p in y) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }
            }

            for (p in x) {
                if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                    return false;
                }
                else if (typeof y[p] !== typeof x[p]) {
                    return false;
                }

                switch (typeof (x[p])) {
                    case 'object':
                    case 'function':

                        leftChain.push(x);
                        rightChain.push(y);

                        if (!compare2Objects (x[p], y[p])) {
                            return false;
                        }

                        leftChain.pop();
                        rightChain.pop();
                        break;

                    default:
                        if (x[p] !== y[p]) {
                            return false;
                        }
                        break;
                }
            }

            return true;
          }

          if (arguments.length < 1) {
            return true; //Die silently? Don't know how to handle such case, please help...
            // throw "Need two or more arguments to compare";
          }

          for (i = 1, l = arguments.length; i < l; i++) {

              leftChain = []; //Todo: this can be cached
              rightChain = [];

              if (!compare2Objects(arguments[0], arguments[i])) {
                  return false;
              }
          }

          return true;
        }

        function updateHTML() {
          let textarea = document.getElementById("json");
          let json = parseJSON(textarea.value);
          if (json === undefined) {
            ssaError("bad JSON");
            return;
          }
          let cols = json.cols;
          if (cols === undefined) {
            ssaError("no cols");
            return;
          }
          if (!Array.isArray(cols)) {
            ssaError("expected cols to be an array");
            return;
          }
          let tr = document.querySelector("#ssa-tr");
          let prev = null;
          for (let col of cols) {
            if (col == null) {
              // Not all columns may be present. Sometimes source, for example,
              // isn't available.
              continue;
            }
            if (prev === null || !deepCompare(col.blocks, prev.blocks)) {
              let collapsed = document.createElement("td");
              collapsed.setAttribute("id", `${col.name}-col`);
              collapsed.setAttribute("class", "collapsed");
              let div = document.createElement("div");
              div.appendChild(document.createTextNode(col.name));
              collapsed.appendChild(div);
              tr.appendChild(collapsed);

              let expanded = document.createElement("td");
              expanded.setAttribute("id", `${col.name}-exp`);
              let h2 = document.createElement("h2");
              h2.appendChild(document.createTextNode(col.name));
              if (col.time_ns !== undefined) {
                const time_ns = document.createElement("span");
                time_ns.setAttribute("class", "stats");
                time_ns.innerText = ` [${col.time_ns} ns]`;
                h2.appendChild(time_ns);
              }
              expanded.appendChild(h2);
              if (col.type == "text") {
                // Print line numbers
                let numbered_lines = [];
                {
                  let numbers = document.createElement("div");
                  numbers.setAttribute("class", "lines");
                  numbers.setAttribute("style", "width: 8%");
                  {
                    let nbsp = document.createElement("div");
                    nbsp.innerHTML = "&nbsp;";
                    numbers.appendChild(nbsp);
                  }
                  {
                    let nbsp = document.createElement("div");
                    nbsp.innerHTML = "&nbsp;";
                    numbers.appendChild(nbsp);
                  }
                  let line_number = col.first_line_number;
                  let line_index = 0;
                  for (let line of col.lines) {
                    let line_div = document.createElement("div");
                    line_div.setAttribute("class", `l${line_number} line-number`);
                    line_div.appendChild(document.createTextNode(line_number));
                    numbers.appendChild(line_div);
                    numbered_lines.push([line_number, col.lines[line_index]]);
                    line_number++;
                    line_index++;
                  }
                  expanded.appendChild(numbers);
                }
                // Print source lines
                {
                  let lines_div = document.createElement("div");
                  let lines = document.createElement("pre");
                  lines_div.appendChild(lines);
                  {
                    let nbsp = document.createElement("div");
                    nbsp.innerHTML = "&nbsp;";
                    lines.appendChild(nbsp);
                  }
                  {
                    let filename = document.createElement("div");
                    let strong = document.createElement("strong");
                    strong.appendChild(document.createTextNode(col.filename));
                    filename.appendChild(strong);
                    lines.appendChild(filename);
                  }
                  for (const [line_number, line] of numbered_lines) {
                    let line_div = document.createElement("div");
                    line_div.setAttribute("class", `l${line_number} line-number`);
                    // If the line is completely empty (no whitespace, even),
                    // force display it with a space.
                    line_div.appendChild(document.createTextNode(line || " "));
                    lines.appendChild(line_div);
                  }
                  expanded.appendChild(lines_div);
                }
              } else if (col.type == "asm") {
                const code = document.createElement("code");
                for (const block of col.blocks) {
                  const block_ul = document.createElement("ul");
                  // TODO(emacs): Figure out what to use as block name in class list
                  block_ul.setAttribute("class", `ssa-print-func`);
                  const start_block = document.createElement("li");
                  start_block.setAttribute("clasS", "ssa-start-block");
                  if (block.origin !== undefined) {
                    // From an HIR instruction
                    start_block.appendChild(formatInstr(block.origin));
                  } else {
                    // Normal text name
                    start_block.innerHTML = `<span class="${block.name} ssa-block">${block.name}</span>`;
                  }
                  const button = collapseButton();
                  start_block.appendChild(button);
                  block_ul.appendChild(start_block);
                  const value_list = document.createElement("li");
                  value_list.setAttribute("class", "ssa-value-list");
                  const value_list_ul = document.createElement("ul");
                  for (const instr of block.instrs) {
                    const instr_li = document.createElement("li");
                    if (col.name == "Bytecode") {
                      instr_li.setAttribute("class", `bc${instr.address} bytecode-offset bytecode-instruction ssa-long-value`);
                    } else {
                      instr_li.setAttribute("class", "ssa-long-value");
                    }
                    instr_li.appendChild(formatLine(instr.line));
                    if (instr.address !== undefined) {
                      instr_li.appendChild(document.createTextNode(` ${instr.address}: ${instr.opcode}`));
                    } else {
                      instr_li.appendChild(document.createTextNode(` ${instr.opcode}`));
                    }
                    if (instr.events !== undefined) {
                      const events_elt = document.createElement("div");
                      events_elt.setAttribute("class", "perf-annotation");
                      for (const event in instr.events) {
                        const event_elt = document.createElement("span");
                        event_elt.innerText = `${event}: ${instr.events[event]} `;
                        events_elt.appendChild(event_elt);
                      }
                      instr_li.appendChild(events_elt);
                    }
                    value_list_ul.appendChild(instr_li);
                  }
                  value_list.appendChild(value_list_ul);
                  block_ul.appendChild(value_list);
                  code.appendChild(block_ul);
                  if (col.name == "Assembly" && block.origin === undefined) {
                    // Hide non-HIR chunks of machine code by default
                    hideBlock(button);
                  }
                }
                expanded.appendChild(code);
              } else if (col.type == "ssa") {
                const code = document.createElement("code");
                for (const block of col.blocks) {
                  const block_ul = document.createElement("ul");
                  block_ul.setAttribute("class", `${block.name} ssa-print-func`);
                  const start_block = document.createElement("li");
                  start_block.setAttribute("class", "ssa-start-block");
                  start_block.appendChild(formatBlock(block.name));
                  if (block.preds !== undefined && block.preds.length > 0) {
                    start_block.appendChild(document.createTextNode(" (preds "));
                    let sep = "";
                    for (const pred of block.preds) {
                      start_block.appendChild(document.createTextNode(sep));
                      start_block.appendChild(formatBlock(pred));
                      sep = ", ";
                    }
                    start_block.appendChild(document.createTextNode(")"));
                  }
                  start_block.appendChild(collapseButton());
                  block_ul.appendChild(start_block);
                  const value_list = document.createElement("li");
                  value_list.setAttribute("class", "ssa-value-list");
                  const value_list_ul = document.createElement("ul");
                  for (const instr of block.instrs) {
                    value_list_ul.appendChild(formatInstr(instr));
                  }
                  value_list.appendChild(value_list_ul);
                  block_ul.appendChild(value_list);
                  const end_block = document.createElement("li");
                  end_block.setAttribute("class", "ssa-end-block");
                  const terminator = document.createElement("span");
                  terminator.setAttribute("class", `${block.name} ssa-block`);
                  const terminator_ul = document.createElement("ul");
                  terminator_ul.appendChild(formatInstr(block.terminator));
                  terminator.appendChild(terminator_ul);
                  end_block.appendChild(terminator);
                  if (block.succs !== undefined && block.succs.length > 0) {
                    end_block.appendChild(document.createTextNode(" (succs "));
                    let sep = "";
                    for (const pred of block.succs) {
                      end_block.appendChild(document.createTextNode(sep));
                      end_block.appendChild(formatBlock(pred));
                      sep = ", ";
                    }
                    end_block.appendChild(document.createTextNode(")"));
                  }
                  block_ul.appendChild(end_block);
                  code.appendChild(block_ul);
                }
                expanded.appendChild(code);
              } else {
                ssaError("unknown representation");
                return;
              }
              tr.appendChild(expanded);
            }
            prev = col;
          }
          ssaSuccess();
          if (json.fullname !== undefined) {
            document.title = json.fullname;
            document.querySelector("body h1").innerText = json.fullname;
          }
          setupTds();
          setupSSA();
        }
    </script>

</head>

<body>
    <h1>main</h1>
    <a href="#" onclick="toggle_visibility('help');return false;" id="helplink">help</a>
    <div id="help">

        <p>
            Click on a value or block to toggle highlighting of that value/block
            and its uses. (Values and blocks are highlighted by ID, and IDs of
            dead items may be reused, so not all highlights necessarily correspond
            to the clicked item.)
        </p>

        <p>
            Faded out values and blocks are dead code that has not been eliminated.
        </p>

        <p>
            Values printed in italics have a dependency cycle.
        </p>

        <p>
            <b>CFG</b>: Dashed edge is for unlikely branches. Blue color is for backward edges.
            Edge with a dot means that this edge follows the order in which blocks were laidout.
        </p>

    </div>
    <label for="dark-mode-button" style="margin-left: 15px; cursor: pointer;">darkmode</label>
    <input type="checkbox" onclick="toggleDarkMode();" id="dark-mode-button" style="cursor: pointer" />
    <label for="perf-annotations-button" style="margin-left: 15px; cursor: pointer;">hide perf annotation</label>
    <input type="checkbox" onclick="togglePerfAnnotations();" id="perf-annotations-button" style="cursor: pointer" />
    <br />
    <!-- TODO: maybe put preds/succs in JSON explicitly -->
    <textarea id="json" style="display: none" oninput="updateHTML()">
@JSON@
    </textarea>
    <div id="ssa-error"></div>
    <table>
        <tr id="ssa-tr">
        </tr>
    </table>
</body>

</html>
